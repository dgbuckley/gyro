'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/getting-started/','title':"Getting Started",'section':"Docs",'content':"Getting Started #  Installation #  In order to install gyro, all you need to do is extract one of the release tarballs for your system and add the single static binary to your PATH.\nBuilding #  If you\u0026rsquo;d like to build from source, the only thing you need is the zig compiler:\ngit clone https://github.com/mattnite/gyro.git --recursive zig build -Dbootstrap The -Dbootstrap is required because gyro uses git submodules to do the initial build. After that one can build gyro with gyro, this will pull packages from the package index instead of using git submodules.\ngyro build (Note: you might need to move the original gyro binary from the zig-cache first). This command wraps zig build, so you can pass arguements like you normally would, like gyro build test to run your unit tests.\nConsuming packages #  To find potential zig packages you\u0026rsquo;d like to use:\n astrolabe.pm, the default package index zpm, a site that lists cool zig projects and where to find them search github for #zig and #zig-package tags  If you want to use code from a package from astrolabe, then all you need to do is gyro add \u0026lt;package name\u0026gt;, else if you want to use a Github repository as a dependency then all that\u0026rsquo;s required is gyro add \u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt;.\nPackages are exposed to your build.zig file through a struct in @import(\u0026quot;gyro\u0026quot;), and you can simply add them using a addAllTo() function, and then @import() in your code.\nAssume there is a hello_world package available to on the index, we\u0026rsquo;d add it to our project like so:\ngyro add hello_world build.zig:\nconst Builder = @import(\u0026#34;std\u0026#34;).build.Builder; const pkgs = @import(\u0026#34;gyro\u0026#34;).pkgs; pub fn build(b: *Builder) void { const exe = b.addExecutable(\u0026#34;main\u0026#34;, \u0026#34;src/main.zig\u0026#34;); pkgs.addAllTo(exe); exe.install(); } main.zig:\nconst hw = @import(\u0026#34;hello_world\u0026#34;); pub fn main() !void { try hw.greet(); } If you want to \u0026ldquo;link\u0026rdquo; a specific package to an object, the packages you depend on are accessed like pkgs.\u0026lt;package name\u0026gt; so in the example above you could instead do exe.addPackage(pkgs.hello_world).\nBuild dependencies #  It\u0026rsquo;s also possible to use packaged code in your build.zig, since this would only run at build time and most likely not required in your application or library these are kept separate from your regular dependencies in your project file.\nWhen you want to add a dependency as a build dep, all you need to do is add --build-dep to the gyro invocation. For example, let\u0026rsquo;s assume I need to do some parsing with a package called mecha:\ngyro add --build-dep mecha and in my build.zig:\nconst Builder = @import(\u0026#34;std\u0026#34;).build.Builder; const pkgs = @import(\u0026#34;gyro\u0026#34;).pkgs; const mecha = @import(\u0026#34;mecha\u0026#34;); pub fn build(b: *Builder) void { const exe = b.addExecutable(\u0026#34;main\u0026#34;, \u0026#34;src/main.zig\u0026#34;); pkgs.addAllTo(exe); exe.install(); } Producing packages #  The easiest way for an existing project to adopt gyro is to start by running gyro init \u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt; to grab metadata from their Github project. From there the package maintainer to finish the init process by defining a few more things:\n the root file, it is src/main.zig by default file globs describing which files are actually part of the package. It is encouraged to include the license and readme, as well as testing code. any other packages if the repo exports multiple repos (and their corresponding root files of course) dependencies (see previous section).  A note on projects and dependencies #  A project may export multiple packages, each with their own root file. For the sake of simplicity all packages in a project share the same dependencies.\n"});})();